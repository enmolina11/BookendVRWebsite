<!DOCTYPE html>
<html>
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="authoring-tool" content="Adobe_Animate_CC">
	<title>Press Kit</title>
	<link href="main.css" rel="stylesheet" type="text/css" />
	<link href="https://fonts.googleapis.com/css?family=Amatic+SC" rel="stylesheet" /><!-- write your code here-->
</head>
<body onload="init();" style="margin:0px;">
<p style="color:white; text-align:center; font-size:200%; letter-spacing: 1px; padding: 50px"><br />
<img alt="Cover" src="/Images/BOOKEND draft 1.png" style="width:900px; height: 500px;" /><br />

<br>In <i>Bookend</I>, play as a child who decides to read their favorite book, <i>The Little Witch</i>, while awaiting the apocalypse. Harnessing the power of a child's imagination through VR, players assist the little witch Abigail in her journey to save her village by intervening in critical parts of the story. And as the story progresses, both Abigail and the player come ever closer to their ends. <br />

<br>Originally a horror game under the title <i>Beloved, Bookend</i> is a game that seeks to play with the conventions of virtual reality by subverting what the players think they can do in the VR space. All throughout the development process, we've tried to reflect this design pillar. <br />

<br> <img alt="MobDraft" src="/Images/MobSketch1.png" style="width:600px; height: 450px;" /><br />
<br /><img align="left" alt="MoonAltar" src="/Images/Environment Concepts4.png" style="width:500px; height: 450px; padding: 25px" /> <br />

<br>Examples include:
  <br>Guiding the protagonist, as opposed to being one, lends a second person perspective to our game.
  <br>Players can only interact with specific items in the pop-up book, and not every single item in the space. <br />

<br>VR is a medium that naturally affords player interactivity not available in most video games. By limiting player interaction while still immersing the player in a rich world, we hope that <i>Bookend</i> will be successful in reflecting what he hope to accomplish. <br />

<br /> <br /> Platform(s): Oculus <br/> Made in Unity <br /> Release Date: June 2018

<br /> <br /><a href="home.html">Back</a></p>
<style type="text/css">#animation_container, #_preload_div_ {
	position:absolute;
	margin:auto;
	left:0;right:0;
  }
  body
  {
    background-color:black;
  }
</style>
<script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script><script>
function LoadGFonts(families, comp) {				
	var lib=comp.getLibrary();				
	var googleObject = {type: "Google", loadedFonts: 0, totalFonts: families.length, callOnLoad: lib.gfontAvailable};				
	for(var i =0; i < families.length; i++)				
		isFontAvailable(gFontsFamilies[i], googleObject);				
}
function isFontAvailable(font, obj) {				
	var timeOut = 5000;				
	var delay = 200;				
	var interval = 0;				
	var timeElapsed = 0;				
	function checkFont() {				
		var node = document.createElement("span");				
		node.innerHTML = "giItT1WQy@!-/#";				
		node.style.position      = "absolute";				
		node.style.left          = "-1000px";				
		node.style.top           = "-1000px";				
		node.style.fontSize      = "300px";				
		node.style.fontFamily    = "sans-serif";				
		node.style.fontVariant   = "normal";				
		node.style.fontStyle     = "normal";				
		node.style.fontWeight    = "normal";				
		node.style.letterSpacing = "0";				
		document.body.appendChild(node);				
		var width = node.offsetWidth;				
		node.style.fontFamily = font+","+node.style.fontFamily;				
		var returnVal = false;				
		if((node && node.offsetWidth != width) || timeElapsed >=timeOut) {				
			obj.loadedFonts++;				
			if(interval)				
				clearInterval(interval);				
			obj.callOnLoad(font, obj.totalFonts);				
			returnVal = true;				
		}				
		if(node) {				
			node.parentNode.removeChild(node);				
			node = null;				
		}				
		timeElapsed += delay;				
		return returnVal;				
	}				
	if(!checkFont()) {				
		interval = setInterval(checkFont, delay);				
	}				
}
</script><script>
	var gFontsFamilies = ["Amatic SC"];
</script></body>
<link href="https://fonts.googleapis.com/css?family=Amatic+SC:regular&amp;subset=latin" rel="stylesheet" type="text/css" /><script src="about.js"></script><script>
var canvas, stage, exportRoot, anim_container, dom_overlay_container, fnStartAnimation;
function init() {
	canvas = document.getElementById("canvas");
	anim_container = document.getElementById("animation_container");
	dom_overlay_container = document.getElementById("dom_overlay_container");
	var comp=AdobeAn.getComposition("542D2293D99641A6B30676A46DA08CDA");
	var lib=comp.getLibrary();
	try {
		if(!(typeof gFontsFamilies === 'undefined' || gFontsFamilies === null))
			LoadGFonts(gFontsFamilies, comp);		
		if(!(typeof totalTypekitFonts === 'undefined' || totalTypekitFonts === null)) {			
			var typekitObject = {type: 'Typekit', loadedFonts: 0, totalFonts: totalTypekitFonts, callOnLoad: lib.tfontAvailable};		
			Typekit.load({
			async: true,
			'fontactive': function(family) {
				isFontAvailable(family, typekitObject);
				}
			});
		}
	} catch(e) {};
	var loader = new createjs.LoadQueue(false);
	loader.addEventListener("fileload", function(evt){handleFileLoad(evt,comp)});
	loader.addEventListener("complete", function(evt){handleComplete(evt,comp)});
	var lib=comp.getLibrary();
	loader.loadManifest(lib.properties.manifest);
}
function handleFileLoad(evt, comp) {
	var images=comp.getImages();	
	if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }	
}
function handleComplete(evt,comp) {
	//This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
	var lib=comp.getLibrary();
	var ss=comp.getSpriteSheet();
	var queue = evt.target;
	var ssMetadata = lib.ssMetadata;
	for(i=0; i<ssMetadata.length; i++) {
		ss[ssMetadata[i].name] = new createjs.SpriteSheet( {"images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames} )
	}
	var preloaderDiv = document.getElementById("_preload_div_");
	preloaderDiv.style.display = 'none';
	canvas.style.display = 'block';
	exportRoot = new lib.About();
	stage = new lib.Stage(canvas);
	stage.enableMouseOver();	
	//Registers the "tick" event listener.
	fnStartAnimation = function() {
		stage.addChild(exportRoot);
		createjs.Ticker.setFPS(lib.properties.fps);
		createjs.Ticker.addEventListener("tick", stage);
	}	    
	//Code to support hidpi screens and responsive scaling.
	function makeResponsive(isResp, respDim, isScale, scaleType) {		
		var lastW, lastH, lastS=1;		
		window.addEventListener('resize', resizeCanvas);		
		resizeCanvas();		
		function resizeCanvas() {			
			var w = lib.properties.width, h = lib.properties.height;			
			var iw = window.innerWidth, ih=window.innerHeight;			
			var pRatio = window.devicePixelRatio || 1, xRatio=iw/w, yRatio=ih/h, sRatio=1;			
			if(isResp) {                
				if((respDim=='width'&&lastW==iw) || (respDim=='height'&&lastH==ih)) {                    
					sRatio = lastS;                
				}				
				else if(!isScale) {					
					if(iw<w || ih<h)						
						sRatio = Math.min(xRatio, yRatio);				
				}				
				else if(scaleType==1) {					
					sRatio = Math.min(xRatio, yRatio);				
				}				
				else if(scaleType==2) {					
					sRatio = Math.max(xRatio, yRatio);				
				}			
			}			
			canvas.width = w*pRatio*sRatio;			
			canvas.height = h*pRatio*sRatio;
			canvas.style.width = anim_container.style.width = dom_overlay_container.style.width = preloaderDiv.style.width = w*sRatio+'px';				
			canvas.style.height = anim_container.style.height = dom_overlay_container.style.height = preloaderDiv.style.height = h*sRatio+'px';
			stage.scaleX = pRatio*sRatio;			
			stage.scaleY = pRatio*sRatio;			
			lastW = iw; lastH = ih; lastS = sRatio;            
			stage.tickOnUpdate = false;            
			stage.update();            
			stage.tickOnUpdate = true;		
		}
	}
	makeResponsive(true,'both',false,1);	
	AdobeAn.compositionLoaded(lib.properties.id);
	fnStartAnimation();
}
</script></html>